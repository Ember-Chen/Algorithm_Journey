---
title: 前k个高频元素
date: 2024-04-24
category: 栈与队列
---

url: https://leetcode.com/problems/top-k-frequent-elements/



- 整体步骤
  1. 遍历原数组，求得各元素出现频率
  2. 利用**PriorityQueue**进行排序
  3. 将最终的pq赋值给结果数组，返回

- 利用PriorityQueue排序的核心差别
  - 如果只是直接对所有元素进行quick sort，时间复杂度为O(nlogn)
  - 但由于只需要前k个高频元素，所以没必要全部进行排序
  - 所以利用PriorityQueue, 底层实现是堆排序，并且控制pq的大小维持在k，则整体的排序时间复杂度为O(nlogk)
- 使用pq的注意点
  - 因为最终要的是最大的前k个元素，所以应该使用**小顶堆**
  - 因为保持pq大小为k的方法是：当大小为k时，每次offer一个元素，就同时poll一个元素。因此应该要保证poll的元素是整个pq中最小的元素。
- HashMap的优化点
  - 由于数组中num的取值范围很大，因此不方便直接使用**数组映射**的方法来实现HashMap；所以比较直接的方式是直接使用HashMap
  - 但是当数据量很大时，HashMap性能不佳；因此可以考虑在某些情形下使用数组映射
  - 实现**大取值范围使用数组映射**的方式：先遍历一次原数据，找出max和min，则只需要创建一个大小为(max-min+1)的数组即可；映射时，任意数字`num`所对应的元素即为`mapAry[num-min]`
  - *进一步优化：因为映射法的潜在问题是，如果max和min差距过大，而实际数据量很小的话，就会造成大量空间浪费；因此可以在遍历得到max和min后，再增加一层判断，决定是采用**数组映射**，还是**HashMap**