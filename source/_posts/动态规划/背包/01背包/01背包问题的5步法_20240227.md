---
title: 01背包问题的5步法
date: 2024-02-27
category: [动态规划,背包,01背包]
---

## 二维数组模型

1. 确定`dp[i][j]`的实际含义：在0~i号物品中进行选择，背包大小为j，此情形下能够容纳的最大价值
2. 确定递归公式：
   - 要求`dp[i][j]`的值，有2种情况
     - 物品i 不放进背包：当`weight[i]>j`时，i无法放进，因此`dp[i][j]=dp[i-1][j]`
     - 物品i 有放进背包：当`weight[i]<=j`时，i可以放进，因此`dp[i][j]=dp[i-1][j-weight[i]]+value[i]`
   - 综合来看，得出`dp[i][j]=max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])`
3. 初始化数组
   - 对于`dp[i][0]`：背包容量为0，价值一定全部为0
   - 对于`dp[0][j]`：只能选0号物品，所以当`j>=weight[0]`时,`dp[0][j]=value[0]`
4. 确认递归顺序方向
   - 双重for循环
   - 可以先遍历物品，也可以先遍历背包；遍历物品更直观
   - 因为每一点的值只取决于其左上角的值；所以遍历先后都可
5. 演算

- 区别于滚动数组的关键点：每个点的取值来源于其左上角的值；而二维数组中，从左到右遍历，也不会覆盖掉左上角的原始值；所以从左到右遍历



## 滚动一维数组模型

- 核心差别

  1. dp数组的实际含义：`dp[j]`->背包大小为j时的最大价值

  2. 递推公式

     - ```java
       for(int i=0;i<weight.length;i+=1)
           dp[j]=max(dp[j],dp[j-weight[i]]+value[i]);
       
       // 背包大小为j时的最大价值 = 2种情况中的最优解
       // 1-不放入物品i：则此时dp[i][j]=dp[i-1][j]
       // 		而在滚动数组中，dp[j]在被更新前，就代表着dp[i-1][j]
       // 2-放入物品i：相似的意思
       ```

  3. 遍历顺序：必须从右到左遍历

     - 因为`dp[j]`在被更新前表示`dp[i-1][j]`；而所有点的赋值都需要其左上角的原始值
     - 因此需要从右到左，才不会发生覆盖

